import { Injectable } from "@nestjs/common";
import {
	LessonModel,
	ExerciseModel,
	UserExerciseProgressModel,
	UserLessonProgressModel,
} from "@db/models";
import { Types } from "mongoose";
import { GeminiService } from "@modules/ai/gemini.service";

@Injectable()
export class PersonalizedLessonService {
	constructor(private readonly geminiService: GeminiService) {}

	async autoGenerateIfNeeded(userId: string): Promise<boolean> {
		const objectId = new Types.ObjectId(userId);

		const lessons = await UserLessonProgressModel.find({
			user_id: objectId,
			completed_at: { $ne: null },
			used_in_personalized: { $ne: true },
		})
			.sort({ completed_at: -1 })
			.limit(3);

		if (lessons.length < 3) return false;

		const mistakes = await UserExerciseProgressModel.find({
			user_id: objectId,
			is_mistake: true,
		})
			.sort({ completed_at: -1 })
			.limit(15);

		if (!mistakes.length) return false;

		const lessonId = await this.generateLessonFromMistakes(userId);

		const usedLessonIds = lessons.map((l) => l.lesson_id);
		await UserLessonProgressModel.updateMany(
			{ user_id: objectId, lesson_id: { $in: usedLessonIds } },
			{ $set: { used_in_personalized: true } },
		);

		return true;
	}

	private extractJson(text: string): string {
		const match = text.match(/```json([\s\S]*?)```/);
		return match ? match[1].trim() : text.trim();
	}

	async generateLessonFromMistakes(userId: string): Promise<string> {
		const objectId = new Types.ObjectId(userId);

		const mistakenProgresses = await UserExerciseProgressModel.find({
			user_id: objectId,
			is_mistake: true,
		})
			.sort({ completed_at: -1 })
			.limit(10)
			.populate("exercise_id");

		if (!mistakenProgresses.length) {
			throw new Error("Kh√¥ng c√≥ l·ªói sai n√†o ƒë·ªÉ t·∫°o b√†i h·ªçc.");
		}

		const mistakeSummary = mistakenProgresses
			.map((p, i) => {
				const ex = p.exercise_id as any;
				return `(${i + 1}) C√¢u h·ªèi: ${ex.question}\nC√¢u sai: ${p.user_answer}\nƒê√∫ng: ${ex.correct_answer}`;
			})
			.join("\n");

		const prompt = `
Ng∆∞·ªùi h·ªçc ƒë√£ l√†m sai c√°c c√¢u sau:
${mistakeSummary}

H√£y t·∫°o m·ªôt b√†i h·ªçc c√° nh√¢n ho√° v·ªõi **15 c√¢u h·ªèi** gi√∫p ng∆∞·ªùi h·ªçc luy·ªán l·∫°i c√°c l·ªói sai tr√™n.

üéØ Y√™u c·∫ßu n·ªôi dung:
- C√¢u h·ªèi ph·∫£i c√≥ **t√≠nh suy lu·∫≠n, logic**, kh√¥ng qu√° ƒë∆°n gi·∫£n ho·∫∑c ch·ªâ c·∫ßn nh·ªõ l·∫°i.
- M·ªói c√¢u n√™n bu·ªôc ng∆∞·ªùi h·ªçc ph·∫£i **hi·ªÉu ng·ªØ c·∫£nh, c·∫•u tr√∫c ng·ªØ ph√°p ho·∫∑c √Ω nghƒ©a t·ª´ v·ª±ng** ƒë·ªÉ tr·∫£ l·ªùi ch√≠nh x√°c.
- C√¢u h·ªèi n√™n ph√π h·ª£p v·ªõi tr√¨nh ƒë·ªô **s∆° c·∫•p ƒë·∫øn trung c·∫•p** ti·∫øng Anh.
- N·ªôi dung c√¢u h·ªèi v√† c√¢u tr·∫£ l·ªùi **d√πng ti·∫øng Anh**.

üìö Ph√¢n b·ªë d·∫°ng c√¢u h·ªèi:
T·∫°o **3 c√¢u h·ªèi cho m·ªói d·∫°ng** trong c√°c d·∫°ng sau (t·ªïng 15 c√¢u):
1. **fill_in_blank** ‚Äì Ch·ªçn t·ª´ ƒë√∫ng ƒë·ªÉ ƒëi·ªÅn v√†o ch·ªó tr·ªëng
2. **match** ‚Äì N·ªëi hai c·ªôt n·ªôi dung t∆∞∆°ng ·ª©ng (nh∆∞ t·ª´ v√† nghƒ©a, ho·∫∑c ch·ªß ƒë·ªÅ v√† v√≠ d·ª•)
3. **reorder** ‚Äì X·∫øp l·∫°i c√°c m·∫£nh gh√©p th√†nh c√¢u ho√†n ch·ªânh
4. **image_select** ‚Äì Ch·ªçn h√¨nh ·∫£nh ph√π h·ª£p nh·∫•t v·ªõi y√™u c·∫ßu
5. **multiple_choice** ‚Äì Ch·ªçn ƒë√°p √°n ƒë√∫ng trong nhi·ªÅu l·ª±a ch·ªçn

üñº V·ªõi c√°c c√¢u d·∫°ng \`image_select\`:
- C√°c h√¨nh ·∫£nh n√™n l√† ·∫£nh th·ª±c t·∫ø.
- Cung c·∫•p **URL th·∫≠t t·ª´ Google Images** ho·∫∑c ngu·ªìn ·∫£nh t∆∞∆°ng t·ª±, ph√π h·ª£p v·ªõi ch·ªß ƒë·ªÅ c√¢u h·ªèi v√† ƒë√°p √°n.

üì¶ Tr·∫£ v·ªÅ JSON v·ªõi ƒë·ªãnh d·∫°ng:

{
  "title": "T√™n b√†i h·ªçc",
  "description": "M√¥ t·∫£ b√†i h·ªçc",
  "exercises": [
    {
      "question_format": "fill_in_blank",
      "type": "vocabulary",
      "question": "He ___ to school by bike.",
      "options": ["goes", "went", "going", "gone"],
      "correct_answer": "goes"
    },
    {
      "question_format": "match",
      "type": "grammar",
      "question": "Match the phrases with their correct meanings.",
      "options": [
        { "id": "1", "left": "Break the ice", "right": "Make people feel more comfortable" },
        { "id": "2", "left": "Hit the sack", "right": "Go to sleep" }
      ],
      "correct_answer": [
        { "id": "1", "left": "Break the ice", "right": "Make people feel more comfortable" },
        { "id": "2", "left": "Hit the sack", "right": "Go to sleep" }
      ]
    },
    {
      "question_format": "reorder",
      "type": "grammar",
      "question": "Arrange the words to form a correct sentence.",
      "options": ["Although", "raining", "he", "went", "was", "out"],
      "correct_answer": "Although it was raining, he went out"
    },
    {
      "question_format": "image_select",
      "type": "vocabulary",
      "question": "Which one shows someone riding a bicycle?",
      "options": [
        { "image": "https://example.com/bike1.jpg", "value": "riding" },
        { "image": "https://example.com/swim.jpg", "value": "swimming" },
        { "image": "https://example.com/run.jpg", "value": "running" }
      ],
      "correct_answer": "riding"
    },
    {
      "question_format": "multiple_choice",
      "type": "grammar",
      "question": "Which sentence is grammatically correct?",
      "options": [
        "He don't like apples.",
        "He doesn't likes apples.",
        "He doesn't like apples.",
        "He not like apples."
      ],
      "correct_answer": "He doesn't like apples."
    }
  ]
}

Ch·ªâ tr·∫£ l·∫°i JSON, kh√¥ng c·∫ßn gi·∫£i th√≠ch.
`;

		const response = await this.geminiService.generateExplanation(prompt);
		const cleanJson = this.extractJson(response);

		let parsed;
		try {
			parsed = JSON.parse(cleanJson);
		} catch (e) {
			throw new Error("AI tr·∫£ k·∫øt qu·∫£ kh√¥ng h·ª£p l·ªá: " + response);
		}

		if (!Array.isArray(parsed.exercises) || parsed.exercises.length === 0) {
			throw new Error("AI kh√¥ng tr·∫£ v·ªÅ danh s√°ch b√†i t·∫≠p h·ª£p l·ªá");
		}

		return this.createLessonFromAiJson(parsed, userId);
	}

	private async createLessonFromAiJson(
		parsed: any,
		userId: string,
	): Promise<string> {
		const lesson = await LessonModel.create({
			title: parsed.title || "Luy·ªán t·∫≠p AI",
			description: parsed.description || "",
			type: ["grammar"],
			mode: "personalized",
			order: 1,
			xp_reward: 10,
			topic: new Types.ObjectId(),
			extra_data: {
				generated_from: "ai_bulk_mistakes",
				user_id: userId,
				language: "vi",
			},
		});

		await ExerciseModel.insertMany(
			parsed.exercises.map((ex: any) => ({
				lesson: lesson._id,
				question_format: ex.question_format,
				type: ex.type || "grammar",
				question: ex.question,
				correct_answer: ex.correct_answer,
				options: ex.options,
				extra_data: { generated_by: "gemini" },
			})),
		);

		return lesson._id.toString();
	}
}
